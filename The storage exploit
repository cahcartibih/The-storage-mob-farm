local player = game.Players.LocalPlayer
local sticking = false

-- List of blacklisted mob names
local blacklist = {
    "Agent 1",
    "Dark Skeleton",
    "Chess King",
    "Death Angel",
    "Agent 7",
    "Vault Mimic",
    "Venus Guytrap",
    "Shotty Beck",
    "Shotty Ben"
    -- Add more mob names as needed
}

-- Create a ScreenGui
local gui = Instance.new("ScreenGui")
gui.Parent = player.PlayerGui
gui.Enabled = true  -- Ensure GUI is enabled

-- Create a teleport button
local teleportButton = Instance.new("TextButton")
teleportButton.Text = "Teleport to Random Mob"
teleportButton.Size = UDim2.new(0, 200, 0, 50)
teleportButton.Position = UDim2.new(0.5, -100, 0.2, -25)
teleportButton.Parent = gui

-- Create a stop button
local stopButton = Instance.new("TextButton")
stopButton.Text = "Stop Sticking"
stopButton.Size = UDim2.new(0, 200, 0, 50)
stopButton.Position = UDim2.new(0.5, -100, 0.4, -25)
stopButton.Parent = gui
stopButton.Visible = false  -- Initially hidden

-- Function to find a random mob (excluding blacklisted mobs)
local function findRandomMob()
    local mobs = game.Workspace:FindFirstChild("Mobs")
    if mobs then
        local mobChildren = mobs:GetChildren()
        if #mobChildren > 0 then
            local validMobs = {}
            for _, mob in ipairs(mobChildren) do
                local mobName = mob.Name
                local isValid = true
                for _, blacklistedName in ipairs(blacklist) do
                    if mobName == blacklistedName then
                        isValid = false
                        break
                    end
                end
                if isValid then
                    table.insert(validMobs, mob)
                end
            end
            if #validMobs > 0 then
                return validMobs[math.random(1, #validMobs)]
            end
        end
    end
    return nil
end

-- Function to calculate the size of a model based on its parts
local function calculateModelSize(model)
    local parts = model:GetDescendants()
    local minPos, maxPos = Vector3.new(math.huge, math.huge, math.huge), Vector3.new(-math.huge, -math.huge, -math.huge)
    for _, part in ipairs(parts) do
        if part:IsA("BasePart") then
            local partPos = part.Position
            minPos = Vector3.new(math.min(minPos.X, partPos.X), math.min(minPos.Y, partPos.Y), math.min(minPos.Z, partPos.Z))
            maxPos = Vector3.new(math.max(maxPos.X, partPos.X), math.max(maxPos.Y, partPos.Y), math.max(maxPos.Z, partPos.Z))
        end
    end
    return maxPos - minPos
end

-- Function to calculate offset to stick to mob's back
local function calculateOffset(playerPos, mobPos, mobSize)
    local offsetDistance = math.max(mobSize.Z, 10)  -- Minimum offset distance (mobSize.Z is the depth of the mob)
    local offset = (mobPos - playerPos).unit * (offsetDistance + 2)  -- Offset to stick to mob's back
    return mobPos + offset
end

-- Function to teleport to a random mob and stick to its back
local function teleportToRandomMob()
    print("Teleporting to random mob...")
    if not sticking then
        local randomMob = findRandomMob()
        if randomMob then
            print("Random mob found.")
            local humanoidRootPart = randomMob:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                print("HumanoidRootPart found.")
                local mobSize = calculateModelSize(randomMob)
                local newPosition = calculateOffset(player.Character.HumanoidRootPart.Position, humanoidRootPart.Position, mobSize)
                print("New position:", newPosition)
                player.Character:SetPrimaryPartCFrame(CFrame.new(newPosition))
                sticking = true
                stopButton.Visible = true  -- Show stop button
                
                -- Continuously update player's position to stick to the mob's back
                local connection
                connection = game:GetService("RunService").Stepped:Connect(function()
                    if sticking then
                        local newPosition = calculateOffset(player.Character.HumanoidRootPart.Position, humanoidRootPart.Position, mobSize)
                        player.Character:SetPrimaryPartCFrame(CFrame.new(newPosition))
                    else
                        connection:Disconnect()
                    end
                end)
            else
                print("HumanoidRootPart not found.")
            end
        else
            print("No mobs found.")
        end
    end
end

-- Function to stop sticking to the mob
local function stopSticking()
    sticking = false
    stopButton.Visible = false  -- Hide stop button
end

-- Bind functions to button clicks
teleportButton.MouseButton1Click:Connect(teleportToRandomMob)
stopButton.MouseButton1Click:Connect(stopSticking)
